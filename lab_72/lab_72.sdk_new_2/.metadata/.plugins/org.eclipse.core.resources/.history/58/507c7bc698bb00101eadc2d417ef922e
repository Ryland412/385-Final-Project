

/***************************** Include Files *******************************/
#include "hdmi_text_controller.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "sleep.h"

/**********************#ifndef HDMI_TEXT_CONTROLLER_H
#define HDMI_TEXT_CONTROLLER_H


/****************** Include Files ********************/
#include "xil_types.h"
#include "xstatus.h"
#include "xparameters.h"

#define COLUMNS 80
#define ROWS 30
#define PALETTE_START 0x2000

#define STUDENT1NETID "<student1>"
#define STUDENT2NETID "<student2>"

struct TEXT_HDMI_STRUCT {
	uint8_t             VRAM [ROWS*COLUMNS*2]; //Week 2 - extended VRAM
	//declare palette registers here, make sure you properly pad in order to correctly account for
	//gap in address map between VRAM and start of palette and control registers

	uint8_t				padding[3392];
	uint32_t 			PALETTE_REGS[8];
	uint32_t            FRAME_COUNT; //control registers should appear immediately after palette
	uint32_t            DRAWX;
	uint32_t            DRAWY;
};

struct COLOR{
	char name [20];
	uint8_t red;
	uint8_t green;
	uint8_t blue;
};


//you may have to change this line depending on your platform designer
static volatile struct TEXT_HDMI_STRUCT* hdmi_ctrl = XPAR_HDMI_TEXT_CONTROLLER_0_AXI_BASEADDR;

//CGA colors with names
static struct COLOR colors[]={
    {"black",          0x0, 0x0, 0x0},
	{"blue",           0x0, 0x0, 0xa},
    {"green",          0x0, 0xa, 0x0},
	{"cyan",           0x0, 0xa, 0xa},
    {"red",            0xa, 0x0, 0x0},
	{"magenta",        0xa, 0x0, 0xa},
    {"brown",          0xa, 0x5, 0x0},
	{"light gray",     0xa, 0xa, 0xa},
    {"dark gray",      0x5, 0x5, 0x5},
	{"light blue",     0x5, 0x5, 0xf},
    {"light green",    0x5, 0xf, 0x5},
	{"light cyan",     0x5, 0xf, 0xf},
    {"light red",      0xf, 0x5, 0x5},
	{"light magenta",  0xf, 0x5, 0xf},
    {"yellow",         0xf, 0xf, 0x5},
	{"white",          0xf, 0xf, 0xf}
};

/**************************** Type Definitions *****************************/
/**
 *
 * Write a value to a HDMI_TEXT_CONTROLLER register. A 32 bit write is performed.
 * If the component is implemented in a smaller width, only the least
 * significant data is written.
 *
 * @param   BaseAddress is the base address of the HDMI_TEXT_CONTROLLERdevice.
 * @param   RegOffset is the register offset from the base to write to.
 * @param   Data is the data written to the register.
 *
 * @return  None.
 *
 * @note
 * C-style signature:
 * 	void HDMI_TEXT_CONTROLLER_mWriteReg(u32 BaseAddress, unsigned RegOffset, u32 Data)
 *
 */
#define HDMI_TEXT_CONTROLLER_mWriteReg(BaseAddress, RegOffset, Data) \
  	Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))

/**
 *
 * Read a value from a HDMI_TEXT_CONTROLLER register. A 32 bit read is performed.
 * If the component is implemented in a smaller width, only the least
 * significant data is read from the register. The most significant data
 * will be read as 0.
 *
 * @param   BaseAddress is the base address of the HDMI_TEXT_CONTROLLER device.
 * @param   RegOffset is the register offset from the base to write to.
 *
 * @return  Data is the data from the register.
 *
 * @note
 * C-style signature:
 * 	u32 HDMI_TEXT_CONTROLLER_mReadReg(u32 BaseAddress, unsigned RegOffset)
 *
 */
#define HDMI_TEXT_CONTROLLER_mReadReg(BaseAddress, RegOffset) \
    Xil_In32((BaseAddress) + (RegOffset))

/************************** Function Prototypes ****************************/
/**
 *
 * Run a self-test on the driver/device. Note this may be a destructive test if
 * resets of the device are performed.
 *
 * If the hardware system is not built correctly, this function may never
 * return to the caller.
 *
 * @param   baseaddr_p is the base address of the HDMI_TEXT_CONTROLLER instance to be worked on.
 *
 * @return
 *
 *    - XST_SUCCESS   if all self-test code passed
 *    - XST_FAILURE   if any self-test code failed
 *
 * @note    Caching must be turned off for this function to work.
 * @note    Self test may fail if data memory and device are not on the same bus.
 *
 */


void textHDMIColorClr();
void textHDMIDrawColorText(char* str, int x, int y, uint8_t background, uint8_t foreground);
void setColorPalette (uint8_t color, uint8_t red, uint8_t green, uint8_t blue); //Fill in this code
void sleepframe(uint32_t frames);
void paletteTest();
void textHDMIColorScreenSaver();
void hdmiTestWeek2(); //call this for your Week 2 demo

#endif // HDMI_TEXT_CONTROLLER_H
 * **** Function Definitions ***************************/

void paletteTest()
{
	textHDMIColorClr();

	for (int i = 0; i < 8; i ++)
	{
		char color_string[80];
		sprintf(color_string, "Foreground: %d background %d", 2*i, 2*i+1);
		textHDMIDrawColorText (color_string, 0, 2*i, 2*i, 2*i+1);
		sprintf(color_string, "Foreground: %d background %d", 2*i+1, 2*i);
		textHDMIDrawColorText (color_string, 40, 2*i, 2*i+1, 2*i);
	}
	textHDMIDrawColorText ("The above text should cycle through random colors", 0, 25, 0, 1);


	for (int i = 0; i < 10; i++)
	{
		sleep_MB (1);
		for (int j = 0; j < 16; j++)
			setColorPalette(j, 	rand() % 16, rand() % 16,rand() % 16); //set color 0 to random color;

	}
}

void textHDMIColorClr()
{
	for (int i = 0; i<(ROWS*COLUMNS) * 2; i++)
	{
		hdmi_ctrl->VRAM[i] = 0x00;
	}
}

void textHDMIDrawColorText(char* str, int x, int y, uint8_t background, uint8_t foreground)
{
	int i = 0;
	while (str[i]!=0)
	{
		hdmi_ctrl->VRAM[(y*COLUMNS + x + i) * 2] = foreground << 4 | background;
		hdmi_ctrl->VRAM[(y*COLUMNS + x + i) * 2 + 1] = str[i];
		i++;
	}
}

void setColorPalette (uint8_t color, uint8_t red, uint8_t green, uint8_t blue)
{
    //fill in this function to set the color palette entry <color> to <red>, <green>, <blue> 12-bit color
    volatile uint32_t* base = (uint32_t)(hdmi_ctrl + 0x800); // Sets the base to the start of the color_pallete
    int reg_index = color / 2; // Since there are two colors per register
    int is_odd = color % 2;

    uint32_t pal_val = base[reg_index]; // This gets the values stored in our color palette because we only want to change half of the values
    uint32_t color_combo = ((red & 0xF) << 8) | ((green & 0xF) << 4) | (blue & 0xF); // This creates our stored color value all together as u32

    if (!(is_odd)){
        pal_val = (pal_val & ~(0xFFF << 16)) | (color_combo << 16); // This color will go on the right of the reg
    }else{
        pal_val = (pal_val & ~0xFFF) | color_combo;
    }

    base[reg_index] = pal_val;
}

void sleepframe(uint32_t frames)
{
	uint32_t last_frame_count = hdmi_ctrl->FRAME_COUNT;
	while (hdmi_ctrl->FRAME_COUNT < last_frame_count + frames)
	{}
}


void textHDMIColorScreenSaver()
{

	char color_string[80];
    int fg, bg, x, y;
	char dvd_string[80];
	uint8_t old_string[160];
	int dvd_x = 0;
	int dvd_y = 0;
	int dvd_dx = 1;
	int dvd_dy = 1;

	int8_t dvd_colors[3] = {0x07, 0x07, 0x07};
	int8_t dvd_d_colors[3] = {-1, +1, -1};

	paletteTest();
	textHDMIColorClr();

	memset(old_string, 0, sizeof(old_string));
	sprintf(dvd_string, "%s and %s completed ECE 385!", STUDENT1NETID, STUDENT2NETID);

	//initialize palette
	for (int i = 0; i < 16; i++)
	{
		setColorPalette (i, colors[i].red, colors[i].green, colors[i].blue);
	}
	while (1)
	{
		if (hdmi_ctrl->FRAME_COUNT % 10 == 0) //every 10 frames update forground
		{
			//restore VRAM bytes into background to undo 'DVD' text
			memcpy(&(hdmi_ctrl->VRAM[(dvd_y*COLUMNS + dvd_x) * 2]), old_string, strlen(dvd_string)*2);

			if ( (dvd_x + dvd_dx >= 80-strlen(dvd_string)) || (dvd_x + dvd_dx < 0)) //check X bound
				dvd_dx = -1*dvd_dx;
			if ( (dvd_y + dvd_dy >= 30) || (dvd_y + dvd_dy < 0)) //check Y bound
				dvd_dy = -1*dvd_dy;
			dvd_x += dvd_dx;
			dvd_y += dvd_dy;

			//store VRAM bytes into buffer before overwriting with 'DVD' text.
			memcpy(old_string, &(hdmi_ctrl->VRAM[(dvd_y*COLUMNS + dvd_x) * 2]), strlen(dvd_string)*2);
			textHDMIDrawColorText (dvd_string, dvd_x, dvd_y, 0, (rand() % 7) + 9);
		}

		if (hdmi_ctrl->FRAME_COUNT % 30 == 0) //every 30 frames update background
			{
				fg = rand() % 16;
				bg = rand() % 16;
				while (fg == bg)
				{
					fg = rand() % 16;
					bg = rand() % 16;
				}
				sprintf(color_string, "Drawing %s text with %s background", colors[fg].name, colors[bg].name);
				x = rand() % (80-strlen(color_string));
				y = rand() % 30;

				textHDMIDrawColorText (color_string, x, y, bg, fg);
		}

		sleepframe(1);//sleep the rest of the frame
	}
}

//Call this function for your Week 2 test
hdmiTestWeek2()
{
	paletteTest();
	printf ("Palette test passed, beginning screensaver loop\n\r");


    textHDMIColorScreenSaver();
}

